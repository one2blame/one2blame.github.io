---
title: Source code analysis methodology
tags:
  - web-app
  - pentesting
  - reverse
  - engineering
---

## Approaches

Two central approaches are pretty useful for discovering bugs in a web application during source
code analysis: a **top-down** approach and a **bottom-up** approach. So how do we delineate the two?

We start with the concept of **sources** and **sinks**. **Sources** are locations where input is
provided to or handled by the web application from external sources, like an API call. **Sinks** are
locations where the information from a **source** stored or executed upon, like a SQL query against
a database using input parameters from an API call.

A **top-down** approach involves us identifying the data produced by a source and following its path
until it reaches a sink. A **bottom-up** approach involves us identifying where data is handled in
privileged scenarios and tracing that data back to a source.

Both approaches have their own merits and are useful in different scenarios. If we're looking for
initial access, authentication bypasses, or the ability to do bad things without authentication, we
might want to use a **top-down** approach. If we're interested in command execution or abusing other
administrative actions, we might want to use a **bottom-up** approach.

## HTTP routing patterns

To assist in our web application reversing journey, we'll have to recognize common **HTTP routing**
patterns for web applications, web APIs, etc. so we can recognize when we've found a source or a
sink, enabling us to better trace data flow.

**File system routing** is a common scheme, mapping the URL of a request to the host's filesystem. A
web server like Apache will establish a **document root** or **web root** to store externally
accessible files.

**Servlet mappings** are used by Java applications, controlling how the application handles incoming
HTTP requests. Usually, the web application maintains a **web.xml** file that defines the HTTP
routing configuration, mapping URL patterns to particular Java servlets.

**Direct mapping** occurs in other web frameworks like **ExpressJS**, **Spring MVC**, or **Flask**
where the web application explicitly defines a URL pattern and maps the URL pattern to a class or
method in the source code.

## Our checklist

Identifying vulnerabilities in a web application can't just be solely based on intuition, can it?
Let's make a checklist of things to look for, in no particular order, that might uncover interesting
paths to discovering a vulnerability:

- Analyze parts of the web application that receive user input without authentication.
- Review parts of the web application that are likely to receive less attention or scrutiny, like
  post-authentication API calls, etc.
- Investigate user input sanitization thoroughly. Is the sanitization conducted with open source
  libraries, or did they roll their own checkers?
- How are queries created and provided to the underlying database? Does the application parameterize
  query input? Does the application sanitize query input?
- Inspect the logic for account creation or password resets and recovery. Can this functionality be
  bypassed?
- Does the application interact with the host operating system? Can we inject commands?
- Are the programming language-specific vulnerabilities present?
