---
title: SQL injection
tags:
  - sql
  - injection
  - web-app
  - pentesting
---

In this section, we'll cover some common ways of discovering **SQL injection**
vulnerabilities in a web application. First, what is SQL injection? It's when
arbitrary input is used by an attacker to construct the remainder of a SQL query
by the web application before executing the query on the web app's underlying
database. This arbitrary input can be used by an attacker to determine the
format of the SQL query, and then subsequently use that to escape the query and
execute arbitrary SQL commands on the SQL server.

This is particularly dangerous because this allows the attacker to leak
sensitive web application information, or even execute arbitrary commands on the
web application server. More on SQL injection can be found at the references
below:

- [OWASP query parameterization cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html)
- [PortSwigger SQL injection cheat sheet](https://portswigger.net/web-security/sql-injection/cheat-sheet)

## String delimiters

SQL query takes a user-provided string, for example:

```sql
SELECT * FROM myTable WHERE myValue = 'deadbeef'
```

Where `deadbeef` was provided by the user. But if the user provides `deadbeef'`,
the SQL server will run into an error - this string isn't closed. With this lack
of sanitization on user input, we can attack and dump all content for the
current table by executing:

```sql
SELECT * FROM myTable WHERE myValue = 'deadbeef' OR 1=1--'
```

Where we entered the string, `deadbeef' OR 1=1--`. The original SQL query
remains intact, and then we also add an `OR 1=1` clause to leak the rest of the
values in the table. The `--` characters create a comment - SQL will ignore the
remainder of the string.

## Closing functions

In the same vein as [[sql-injection#String delimiters|string delimiters]], the
web application is taking our arbitrary input and providing it to a SQL function
call when constructing the SQL query, e.g.:

```sql
SELECT * FROM myTable WHERE LOWER(myValue) == LOWER('deadbeef')
```

We can break this query with the following example:

```sql
SELECT * FROM myTable WHERE LOWER(myValue) == LOWER('deadbeef') OR 1=1--')
```

Where we provided the input: `deadbeef') OR 1=1--`.

## Sorting

Sometimes web applications sort the output of SQL queries to provide clean
output to the user, e.g.:

```sql
SELECT myValue, myOtherValue FROM myTable ORDER BY 1
```

Where `ORDER BY 1` instructs the SQL server to sort the output in descending
order based on the first column. We can detect whether or not we can control the
value given to the `ORDER BY <NUM>` operation by testing out arbitrary integer
values, or just removing the integer value entirely from the browser's request
to the server. This should, eventually, cause SQL to report an error, being
unable to find the column specified for the `ORDER BY` operation.

## Fuzzing

Using a familiar tool, [[web-app-enumeration#Information disclosure|wfuzz]], we
can use a working POST request to fuzz for irregularities in the web
application's response, attempting to detect a SQL injection vulnerability.
Provided a working POST request, we can use a wordlist with `wfuzz` to try out
different inputs and test the server's response:

```bash
wfuzz -c -z file,/usr/share/wordlists/wfuzz/Injections/SQL.txt -d "db=mysql&id=FUZZ" -u http://<HOSTNAME>/api
```

In the above `bash` invocation, we're directing `wfuzz` to print results using
color, `-c`, using a wordlist, `-z file`, and providing POST request data, `-d`,
to fuzz the target URL, `-u`.

## Error-based payloads

After discovering a SQL injection vulnerability, we want to gain more
information about the target instead of just reading the error output from the
SQL server when attempting to interpret our query. Below are some techniques we
can use against different SQL server providers to leak version information. More
on error based injection attacks:

- [Error Based Injection](https://sqlwiki.netspi.com/injectionTypes/errorBased/#mysql)

**PostgreSQL** and **Microsoft SQL Server**:

```sql
cast(@@version as integer)
```

The victim SQL server retrieves the version string and attempts to `cast` it as
an integer, however, the version string isn't in the correct format for an
integer cast. This causes the SQL server to display an error, leaking the
version information.

**MySQL**

```sql
extractvalue('',concat('>',version()))
```

The victim SQL server retrieves the version string and attempts to store an
empty `XML` fragment into the `XPATH` variable represented by the version
string. This fails as the version string is not a valid `XPATH` variable. The
SQL server displays an error, leaking the version information.

**Oracle**

```sql
  to_char(
    dbms_xmlgen.getxml(
      'select "'||
        (select substr(banner,0,30) from v$version where rownum=1)
      ||'" from sys.dual'
    )
  )
```

The victim SQL server retrieves the version string an truncates it to 30
characters. This is then concatenated to create a SQL query string that is the
first parameter to the `getxml` function call. The result of `getxml` is then
cast to a string. The `getxml` function call fails because the parameter is not
a valid SQL query, and the SQL server displays an error leaking the version
information.

## UNION-based payloads

**`UNION`-based payloads** are useful when targeting a SQL injection
vulnerability that allows to append characters to the tail of a valid
`SELECT`statement, e.g.:

```sql
SELECT myColumn FROM myTable <INJECTION_HERE>
```

Using `UNION ALL`, we can then construct a query like:

```sql
SELECT myColumn FROM myTable UNION ALL SELECT victimColumn FROM victimTable
```

Exposing data from other tables that aren't in the original query. This is a
powerful payload, but sometimes difficult to get working because the number of
columns in the original table is unknown. If we don't request enough columns in
the `UNION` statement, the query will be malformed and rejected by the SQL
server. In that case, we can use static values like `NULL` to ensure our `UNION`
syntax is correct, e.g.:

```sql
SELECT myColumn1, myColumn2 FROM myTable UNION ALL SELECT victimColumn, NULL FROM victimTable
```

Two columns are requested in the original, vulnerable query - we're only
interested in one column from the `victimTable`, therefore we use `NULL` as a
constant value for our `SELECT` statement to replace the second column expected.
Some `UNION`-based payload examples can be found here:

- [Union-Based Injection](https://sqlwiki.netspi.com/injectionTypes/unionBased/#mysql)

## Stacked queries

**Stacked queries** are individual queries submitted at the same time and
executed sequentially. Stacked queries are useful if you're injecting at the
tail end of a vulnerable query - not super useful in the middle of query that
you're potentially breaking up. Stacked queries also aren't guaranteed to return
information back to us, it's likely the web application will only use the
results of the first query. Stacked queries are useful for executing background
tasks, however, allowing us to change data in the target database.

Stacked queries usually require us to terminate the previous query before
injecting our stacked query, e.g.:

```sql
SELECT myColumn FROM myTable WHERE myColumn = 0; SELECT * FROM myTable;
```

Where we injected:

```sql
0; SELECT * FROM myTable;
```

### Time-based blind injection

When attacking a PostgreSQL database, if we have the ability to execute
time-based, blind SQL injection, here's a couple of useful queries to gather
information:

```sql
;SELECT case when (SELECT current_setting($$is_superuser$$))=$$on$$ then pg_sleep(10) end;--+
```

## File manipulation

**File manipulation** on the host of the SQL server is possible if the SQL
server has permissions to read / write to targeted directories, and the user
also permissions to target specific data or files on the server and the host.

For **PostgreSQL**, we can use SQL commands like `pg_read_file` to expose the
contents of files on the host that the SQL server can access, e.g.:

```sql
SELECT pg_read_file('/etc/passwd')
```

For **MySQL**, we similarly have the `LOAD_FILE` function, however, it's
important we check the server's permissions with `file_priv`:

```sql
SELECT file_priv FROM mysql.user WHERE user = <current_user>
```

We can also attempt to verify the permissions in the `@@GLOBAL.secure_file_priv`
variable. More on interacting with the filesystem via SQL can be found here:

- [Reading and Writing Files](https://sqlwiki.netspi.com/attackQueries/readingAndWritingFiles/#mysql)

## Remote code execution (RCE)

Different SQL servers have different ways of enabling operating system command
execution. Some SQL servers, like Microsoft SQL Server, have native ways of
executing system commands, while servers like MySQL might require us to upload a
webshell. More techniques on how to establish an OS command shell can be found
here:

- [Executing OS Commands](https://sqlwiki.netspi.com/attackQueries/executingOSCommands)

## Automation tools

Once you've discovered an injectable SQL query, honestly the best and easiest
way to reliably exploit it is to use **`SQLMap`**. First, use something like
BurpSuite to interact with the target website, gather cookies, valid queries,
etc. Identify the vulnerable parameter(s) and then pass this information to
`SQLMap`. With `SQLMap`, you can determine how invasive or quiet the attack is.
Regardless, `SQLMap` is pretty powerful and has a variety of techniques to both
leak information as well as gain RCE on a target vulnerable to SQL injection.
Official documentation for `SQLMap`can be found here:

- [SQLMap](https://github.com/sqlmapproject/sqlmap/wiki)
